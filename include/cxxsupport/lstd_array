// vim: set filetype=cpp:
// Leka - LekaOS
// Copyright 2021 APF France handicap
// SPDX-License-Identifier: Apache-2.0

#ifndef _LEKA_OS_CXX_SUPPORT_ARRAY_H_
#define _LEKA_OS_CXX_SUPPORT_ARRAY_H_

// ? Information about this header
// ?
// ? The purpose of this header is to provide C++ STL functionalities
// ? not yet available in C++17.
// ?
// ? The content of this header was inspired and/or copied from:
// ?     > https://en.cppreference.com/w/cpp/container/array/to_array
// ?
// ? Under the following license:
// ?     - Creative Commons Attribution-Sharealike 3.0 Unported License (CC-BY-SA)
// ?     - GNU Free Documentation License (GFDL)
// ?
// ? It is therefore made available under the same terms.

// clang-format off

#if __cplusplus >= 201703L && __has_include(<array>)
#include <version>
#endif

#if __cpp_lib_to_array >= 201907L

#include <array>

namespace lstd {

using std::to_array;

}	// namespace lstd

#else	// __cpp_lib_to_array >= 201907L

#include <array>
#include <functional>

// clang-format on

namespace lstd {

namespace details {

	template <typename T, size_t N, size_t... I>
	constexpr auto _to_array(T (&arr)[N], std::index_sequence<I...>) -> std::array<std::remove_cv_t<T>, N>
	{
		return {{arr[I]...}};
	}

	template <typename T, size_t N, size_t... I>
	constexpr auto _to_array(T(&&arr)[N], std::index_sequence<I...>) -> std::array<std::remove_cv_t<T>, N>
	{
		return {{std::move(arr[I])...}};
	}

}	// namespace details

template <typename T, size_t N>
constexpr auto to_array(T (&arr)[N])
{
	return details::_to_array(arr, std::make_index_sequence<N>());
}

template <typename T, size_t N>
constexpr auto to_array(T(&&arr)[N])
{
	return details::_to_array(std::move(arr), std::make_index_sequence<N>());
}

}	// namespace lstd

#endif	 // __cpp_lib_to_array >= 202002L

#endif	 // _LEKA_OS_CXX_SUPPORT_ARRAY_H_
