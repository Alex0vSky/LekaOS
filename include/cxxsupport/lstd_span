// vim: set filetype=cpp:
// Leka - LekaOS
// Copyright 2021 APF France handicap
// SPDX-License-Identifier: Apache-2.0

#ifndef _LEKA_OS_CXX_SUPPORT_SPAN_H_
#define _LEKA_OS_CXX_SUPPORT_SPAN_H_

// clang-format off

// ? Information about this header
// ?
// ? The purpose of this header is to provide C++ STL functionalities
// ? not yet available in C++17.
// ?
// ? The content of this header was inspired and/or copied from:
// ?     > https://github.com/ARMmbed/mbed-os/blob/5fe4dafc349c4b0e93e3d2daeb933977c6851653/platform/cxxsupport/mstd_span
// ?
// ? Under the following license(s):
// ?     - Copyright (c) 2019 ARM Limited
// ?     - Apache-2.0
// ?
// ? It is therefore made available under the same terms.

#if __cplusplus >= 201703L && __has_include(<span>)
#include <version>
#endif

#if __cpp_lib_span >= 202002L

#include <span>

namespace lstd {

using std::dynamic_extent;
using std::span;

}	// namespace lstd

#else	//__cpp_lib_span >= 202002L

#include <array>
#include <iterator>
#include <mstd_iterator>
#include <mstd_type_traits>
#include <type_traits>

// clang-format on

namespace lstd {

constexpr std::size_t dynamic_extent = -1;

template <typename, std::size_t = dynamic_extent>
class span;

namespace detail {

	template <typename ElementType, std::size_t Extent>
	struct storage {
		constexpr storage() noexcept = default;

		constexpr storage(ElementType *ptr, std::size_t size) noexcept : _data(ptr) {}

		ElementType *_data				   = nullptr;
		static constexpr std::size_t _size = Extent;
	};

	template <typename ElementType, std::size_t Extent>
	constexpr std::size_t storage<ElementType, Extent>::_size;

	template <typename ElementType>
	struct storage<ElementType, dynamic_extent> {
		constexpr storage() noexcept = default;

		constexpr storage(ElementType *ptr, std::size_t size) noexcept : _data(ptr), _size(size) {}

		ElementType *_data = nullptr;
		std::size_t _size  = 0;
	};

	template <typename>
	struct is_span : std::false_type {
	};

	template <typename T, std::size_t E>
	struct is_span<span<T, E>> : std::true_type {
	};

	template <typename>
	struct is_std_array : std::false_type {
	};

	template <typename T, std::size_t N>
	struct is_std_array<std::array<T, N>> : std::true_type {
	};

	template <typename, typename = void>
	struct has_size : std::false_type {
	};

	template <typename T>
	struct has_size<T, std::void_t<decltype(std::size(std::declval<T>()))>> : std::true_type {
	};

	template <typename, typename = void>
	struct has_data : std::false_type {
	};

	template <typename T>
	struct has_data<T, std::void_t<decltype(std::data(std::declval<T>()))>> : std::true_type {
	};

	template <typename T, typename U = mstd::remove_cvref_t<T>>
	struct is_container {
		static constexpr bool value = !is_span<U>::value && !is_std_array<U>::value && !std::is_array<U>::value &&
									  has_size<T>::value && has_data<T>::value;
	};

	template <class T>
	using iterator_t = decltype(std::begin(std::declval<T &>()));

	template <class R>
	using range_reference_t = mstd::iter_reference_t<iterator_t<R>>;

	template <typename, typename, typename = void>
	struct is_compatible : std::false_type {
	};

	template <typename T, typename E>
	struct is_compatible<T, E,
						 typename std::enable_if_t<!std::is_same<
							 typename std::remove_cv_t<decltype(std::data(std::declval<T>()))>, void>::value>>
		: std::is_convertible<std::remove_pointer_t<decltype(std::data(std::declval<T>()))> (*)[], E (*)[]> {
	};

}	// namespace detail

template <typename ElementType, std::size_t Extent>
class span
{
  public:
	using element_type	   = ElementType;
	using value_type	   = typename std::remove_cv_t<element_type>;
	using index_type	   = std::size_t;
	using difference_type  = ptrdiff_t;
	using pointer		   = element_type *;
	using const_pointer	   = const element_type *;
	using reference		   = element_type &;
	using const_reference  = const element_type &;
	using iterator		   = pointer;
	using reverse_iterator = std::reverse_iterator<iterator>;

	static constexpr index_type extent = Extent;

	// Constructors, copy and assignment
	template <std::size_t E = Extent, typename std::enable_if_t<E == dynamic_extent, int> = 0>
	constexpr span() noexcept
	{
	}

	template <class It, std::size_t E = Extent,
			  typename std::enable_if_t<std::is_convertible<std::remove_reference_t<mstd::iter_reference_t<It>> (*)[],
															ElementType (*)[]>::value,
										int> = 0>
	constexpr span(It ptr, index_type count) : _storage(ptr, count)
	{
		static_assert(extent == dynamic_extent || extent == count);
	}

	template <class It,
			  typename std::enable_if_t<std::is_convertible<std::remove_reference_t<mstd::iter_reference_t<It>> (*)[],
															ElementType (*)[]>::value,
										int> = 0>
	constexpr span(It first, It last) : _storage(first, last - first)
	{
		static_assert(first <= last);
		static_assert(extent == dynamic_extent || extent == last - first);
		static_assert(extent == 0 || nullptr != first);
	}

	template <std::size_t N>
	constexpr span(
		mstd::type_identity_t<element_type> (&arr)[N],
		typename std::enable_if_t<
			(Extent == dynamic_extent || Extent == N) &&
				std::is_convertible<std::remove_pointer_t<decltype(std::data(arr))> (*)[], ElementType (*)[]>::value,
			int> = 0) noexcept
		: _storage(arr, N)
	{
	}

	template <class T, std::size_t N>
	constexpr span(
		std::array<T, N> &arr,
		typename std::enable_if_t<
			(Extent == dynamic_extent || Extent == N) &&
				std::is_convertible<std::remove_pointer_t<decltype(std::data(arr))> (*)[], ElementType (*)[]>::value,
			int> = 0) noexcept
		: _storage(arr.data(), N)
	{
	}

	template <class T, std::size_t N>
	constexpr span(
		const std::array<T, N> &arr,
		typename std::enable_if_t<
			(Extent == dynamic_extent || Extent == N) &&
				std::is_convertible<std::remove_pointer_t<decltype(std::data(arr))> (*)[], ElementType (*)[]>::value,
			int> = 0) noexcept
		: _storage(arr.data(), N)
	{
	}

	template <class R, typename std::enable_if_t<
						   detail::is_container<R>::value && detail::is_compatible<R &, ElementType>::value, int> = 0>
	constexpr span(R &&r) : _storage(std::data(r), std::size(r))
	{
		static_assert(extent == dynamic_extent || extent == std::size(r));
	}

	constexpr span(const span &other) noexcept = default;

	template <class OtherElementType, std::size_t OtherExtent,
			  typename std::enable_if_t<(Extent == dynamic_extent || OtherExtent == Extent) &&
											std::is_convertible<OtherElementType (*)[], ElementType (*)[]>::value,
										int> = 0>
	constexpr span(const span<OtherElementType, OtherExtent> &s) noexcept : _storage(s.data(), s.size())
	{
	}

	~span() noexcept = default;

	constexpr span &operator=(const span &other) noexcept = default;

	// Subviews
	template <std::size_t Count>
	constexpr span<element_type, Count> first() const
	{
		static_assert(Count <= extent);
		static_assert(Count <= size());
		return {data(), Count};
	}

	template <std::size_t Count>
	constexpr span<element_type, Count> last() const
	{
		static_assert(Count <= extent);
		static_assert(Count <= size());
		return {data() + (size() - Count), Count};
	}

	template <std::size_t Offset, std::size_t Count = dynamic_extent>
	constexpr span<element_type,
				   Count != dynamic_extent ? Count : (Extent != dynamic_extent ? Extent - Offset : dynamic_extent)>
	subspan() const
	{
		static_assert(Offset <= extent && (Count == dynamic_extent || Count <= extent - Offset));
		// Only check against Offset == 0 to prevent a warning for subspan<0, N>
		static_assert((Offset == 0 || Offset <= size()) && (Count == dynamic_extent || Count <= size() - Offset));
		return {data() + Offset, Count != dynamic_extent ? Count : size() - Offset};
	}

	constexpr span<element_type, dynamic_extent> first(index_type count) const
	{
		static_assert(count <= size());
		return {data(), count};
	}

	constexpr span<element_type, dynamic_extent> last(index_type count) const
	{
		static_assert(count <= size());
		return {data() + (size() - count), count};
	}

	constexpr span<element_type, dynamic_extent> subspan(index_type offset, index_type count = dynamic_extent) const
	{
		static_assert(offset <= size() && (count == dynamic_extent || count <= size() - offset));
		return {data() + offset, count == dynamic_extent ? size() - offset : count};
	}

	// Observers
	constexpr index_type size() const noexcept { return _storage._size; }

	constexpr index_type size_bytes() const noexcept { return size() * sizeof(element_type); }

	constexpr bool empty() const noexcept { return size() == 0; }

	// Element access
	constexpr reference operator[](index_type idx) const { return *(data() + idx); }

	constexpr reference front() const { return *data(); }

	constexpr reference back() const { return *(data() + (size() - 1)); }

	constexpr pointer data() const noexcept { return _storage._data; }

	// Iterators
	constexpr iterator begin() const noexcept { return data(); }

	constexpr iterator end() const noexcept { return data() + size(); }

	constexpr reverse_iterator rbegin() const noexcept { return reverse_iterator(end()); }

	constexpr reverse_iterator rend() const noexcept { return reverse_iterator(begin()); }

  private:
	detail::storage<element_type, extent> _storage;
};

// clang-format off

template <typename ElementType, std::size_t Extent>
constexpr typename span<ElementType, Extent>::index_type span<ElementType, Extent>::extent;

#if __cplusplus >= 201703L || __cpp_deduction_guides >= 201703L

// Deduction guides
template <class It, class EndOrSize>
span(It, EndOrSize) -> span<std::remove_reference_t<mstd::iter_reference_t<It>>>;

template <class T, std::size_t N>
span(T (&)[N]) -> span<T, N>;

template <class T, std::size_t N>
span(std::array<T, N> &) -> span<T, N>;

template <class T, std::size_t N>
span(const std::array<T, N> &) -> span<const T, N>;

template <class R>
span(R &&) -> span<std::remove_reference_t<detail::range_reference_t<R>>>;

#endif	 //__cplusplus >= 201703L || __cpp_deduction_guides >= 201703L

// clang-format on

}	// namespace lstd

#endif	 //__cpp_lib_span >= 202002L

#endif	 // _LEKA_OS_CXX_SUPPORT_SPAN_H_
